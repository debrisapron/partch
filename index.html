<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Partch</title>
    <link rel="stylesheet" href="assets/css/bootstrap.css"/>
    <link rel="stylesheet" href="assets/css/bootstrap-responsive.css"/>
    <link rel="stylesheet" href="assets/css/pilcrow.css"/>
    <link rel="stylesheet" href="assets/css/hljs-github.min.css"/>
    <link rel="stylesheet" href="assets/css/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.35.0/codemirror.min.css" />
    <style>
    body {
      background: url('assets/img/textured_paper.png') repeat top left;
      background-color: #f6f6f6;
    }
    .CodeMirror {
      /* border: 1px solid #eee; */
      height: auto;
    }
    .cm-ctrl {
      float: right;
    }
    </style>
  </head>
<body>

  <div class="container-fluid">
    <div class="row-fluid">
      <div class="span3"><ul class="nav nav-list">
    <li class="sidebar-header-1"><a href="#partch">Partch</a></li>
    <li class="sidebar-header-2"><a href="#installation">Installation</a></li>
    <li class="sidebar-header-2"><a href="#example">Example</a></li>
    <li class="sidebar-header-2"><a href="#guide">Guide</a></li>
    <li class="sidebar-header-2"><a href="#api">API</a></li>
    <li class="sidebar-header-3"><a href="#partch([audiocontext])">Partch([audioContext])</a></li>
    <li class="sidebar-header-3"><a href="#p(nodes,-[...connections])">P(nodes, [...connections])</a></li>
    <li class="sidebar-header-4"><a href="#patch.connect(destination)">patch.connect(destination)</a></li>
    <li class="sidebar-header-4"><a href="#patch.input">patch.input</a></li>
    <li class="sidebar-header-4"><a href="#patch.monitor()">patch.monitor()</a></li>
    <li class="sidebar-header-4"><a href="#patch.nodes">patch.nodes</a></li>
    <li class="sidebar-header-4"><a href="#patch.release([time])">patch.release([time])</a></li>
    <li class="sidebar-header-4"><a href="#patch.releaseafter(interval)">patch.releaseAfter(interval)</a></li>
    <li class="sidebar-header-4"><a href="#patch.start([time])">patch.start([time])</a></li>
    <li class="sidebar-header-4"><a href="#patch.stop([time])">patch.stop([time])</a></li>
    <li class="sidebar-header-4"><a href="#patch.stopafter(interval)">patch.stopAfter(interval)</a></li>
    <li class="sidebar-header-3"><a href="#p.adsr([config])">P.Adsr([config])</a></li>
    <li class="sidebar-header-3"><a href="#p.audiocontext">P.audioContext</a></li>
    <li class="sidebar-header-3"><a href="#p.const([config])">P.Const([config])</a></li>
    <li class="sidebar-header-3"><a href="#p.delay([config])">P.Delay([config])</a></li>
    <li class="sidebar-header-3"><a href="#p.filter([config])">P.Filter([config])</a></li>
    <li class="sidebar-header-3"><a href="#p.gain([config])">P.Gain([config])</a></li>
    <li class="sidebar-header-3"><a href="#p.osc([config])">P.Osc([config])</a></li>
    <li class="sidebar-header-3"><a href="#p.shaper([config])">P.Shaper([config])</a></li>
    <li class="sidebar-header-3"><a href="#p.synth(voice)">P.Synth(Voice)</a></li>
    <li class="sidebar-header-2"><a href="#cookbook">Cookbook</a></li>
    <li class="sidebar-header-3"><a href="#simple-delay">Simple delay</a></li>
    <li class="sidebar-header-3"><a href="#analogue-style-delay">Analogue-style delay</a></li>
    <li class="sidebar-header-3"><a href="#flanger">Flanger</a></li>
</ul>
      </div>
      <div class="span9 main"><h1 id="partch"><a class="header-link" href="#partch"></a>Partch</h1>
<p>A lightweight Web Audio API patching library.</p>
<h2 id="installation"><a class="header-link" href="#installation"></a>Installation</h2>
<p><code>yarn add partch</code> or <code>npm install partch --save</code></p>
<h2 id="example"><a class="header-link" href="#example"></a>Example</h2>
<p>First</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> Partch <span class="hljs-keyword">from</span> <span class="hljs-string">'partch'</span>
<span class="hljs-keyword">let</span> P = Partch()</code></pre><p>then</p>
<pre class="hljs"><code>P.Synth(<span class="hljs-function">(<span class="hljs-params">frequency</span>) =&gt;</span> P({
  <span class="hljs-attr">osc</span>: P.Osc({ frequency, <span class="hljs-attr">type</span>: <span class="hljs-string">'sawtooth'</span> }),
  <span class="hljs-attr">vcf</span>: P.Filter(<span class="hljs-number">20</span>),
  <span class="hljs-attr">vca</span>: P.Gain(<span class="hljs-number">0</span>),
  <span class="hljs-attr">env</span>: P.Adsr({ <span class="hljs-attr">attack</span>: <span class="hljs-number">0.01</span>, <span class="hljs-attr">decay</span>: <span class="hljs-number">0.1</span>, <span class="hljs-attr">sustain</span>: <span class="hljs-number">0.6</span>, <span class="hljs-attr">release</span>: <span class="hljs-number">1</span> })
},
  <span class="hljs-string">'osc &gt; vcf &gt; vca &gt; out'</span>,
  <span class="hljs-string">'env &gt; vcf.frequencyCv'</span>,
  <span class="hljs-string">'env &gt; vca.gainCv'</span>
)).monitor().play(<span class="hljs-number">60</span>).releaseAfter(<span class="hljs-number">0.5</span>)</code></pre><h2 id="guide"><a class="header-link" href="#guide"></a>Guide</h2>
<p>TODO.</p>
<h2 id="api"><a class="header-link" href="#api"></a>API</h2>
<h3 id="partch([audiocontext])"><a class="header-link" href="#partch([audiocontext])"></a>Partch([audioContext])</h3>
<ul class="list">
<li><code>audioContext</code> - <em>AudioContext</em> - Defaults to a new AudioContext.</li>
</ul>
<p>Returns a Patch function (henceforth abbreviated as <code>P</code>) with a number of attached Node Factory functions.</p>
<h3 id="p(nodes,-[...connections])"><a class="header-link" href="#p(nodes,-[...connections])"></a>P(nodes, [...connections])</h3>
<ul class="list">
<li><code>nodes</code> - <em>Object</em> - An object where the keys are node names and the values are audio nodes.</li>
<li><code>connections</code> - <em>Array of String</em> - Strings representing connections between nodes.</li>
</ul>
<p>Connection strings take the form of a list of nodes separated by a <code>&gt;</code> character. Each node may be either a node name specified in the <code>nodes</code> object, or a dot-separated node path, e.g. <code>synth.filter.frequencyCv</code>. When using a node path, any onward connections after the node will be from the <strong>top-level</strong> node, i.e. the node whose name comes first in the path.</p>
<p>Returns a patch object with the following members:</p>
<h4 id="patch.connect(destination)"><a class="header-link" href="#patch.connect(destination)"></a>patch.connect(destination)</h4>
<ul class="list">
<li><code>destination</code> - <em>AudioDestinationNode | AudioParam</em> - The destination to connect to.</li>
</ul>
<p>Works exactly like the <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioNode/connect">AudioNode connect method</a>. Returns the destination.</p>
<h4 id="patch.input"><a class="header-link" href="#patch.input"></a>patch.input</h4>
<p>An alias for <code>patch.nodes.in</code>. When connecting from a native Web Audio API node to a patch, this should be the connection destination.</p>
<h4 id="patch.monitor()"><a class="header-link" href="#patch.monitor()"></a>patch.monitor()</h4>
<p>Connects the patch to the <code>audioContext.destination</code>. Returns the patch.</p>
<h4 id="patch.nodes"><a class="header-link" href="#patch.nodes"></a>patch.nodes</h4>
<p>The nodes object used to instantiate the patch, plus the <code>in</code> and <code>out</code> nodes (if present).</p>
<h4 id="patch.release([time])"><a class="header-link" href="#patch.release([time])"></a>patch.release([time])</h4>
<ul class="list">
<li><code>time</code> - <em>Integer</em> - The audioContext time at which to release. Defaults to immediately.</li>
</ul>
<p>Triggers the release portion of any envelopes in the patch at <code>time</code>, then stops the patch. Returns the patch.</p>
<h4 id="patch.releaseafter(interval)"><a class="header-link" href="#patch.releaseafter(interval)"></a>patch.releaseAfter(interval)</h4>
<ul class="list">
<li><code>interval</code> - <em>Integer</em> - The time from now at which to release.</li>
</ul>
<p>Waits <code>interval</code> seconds from now, then calls <code>release</code> above. Returns the patch.</p>
<h4 id="patch.start([time])"><a class="header-link" href="#patch.start([time])"></a>patch.start([time])</h4>
<ul class="list">
<li><code>time</code> - <em>Integer</em> - The audioContext time at which to start. Defaults to immediately.</li>
</ul>
<p>Starts any nodes in the patch which have a <code>start</code> method at <code>time</code> (this will also trigger the attack portion of any envelopes). Returns the patch.</p>
<h4 id="patch.stop([time])"><a class="header-link" href="#patch.stop([time])"></a>patch.stop([time])</h4>
<ul class="list">
<li><code>time</code> - <em>Integer</em> - The audioContext time at which to stop. Defaults to immediately.</li>
</ul>
<p>Stops any nodes in the patch which have a <code>stop</code> method at <code>time</code> (this will cut off sound immediately without triggering the release portion of any envelopes). Returns the patch.</p>
<h4 id="patch.stopafter(interval)"><a class="header-link" href="#patch.stopafter(interval)"></a>patch.stopAfter(interval)</h4>
<ul class="list">
<li><code>interval</code> - <em>Integer</em> - The time from now at which to stop.</li>
</ul>
<p>Waits <code>interval</code> seconds from now, then calls <code>stop</code> above. Returns the patch.</p>
<h3 id="p.adsr([config])"><a class="header-link" href="#p.adsr([config])"></a>P.Adsr([config])</h3>
<p>TODO.</p>
<h3 id="p.audiocontext"><a class="header-link" href="#p.audiocontext"></a>P.audioContext</h3>
<p>TODO.</p>
<h3 id="p.const([config])"><a class="header-link" href="#p.const([config])"></a>P.Const([config])</h3>
<p>TODO.</p>
<h3 id="p.delay([config])"><a class="header-link" href="#p.delay([config])"></a>P.Delay([config])</h3>
<p>TODO.</p>
<h3 id="p.filter([config])"><a class="header-link" href="#p.filter([config])"></a>P.Filter([config])</h3>
<p>TODO.</p>
<h3 id="p.gain([config])"><a class="header-link" href="#p.gain([config])"></a>P.Gain([config])</h3>
<p>TODO.</p>
<h3 id="p.osc([config])"><a class="header-link" href="#p.osc([config])"></a>P.Osc([config])</h3>
<p>TODO.</p>
<h3 id="p.shaper([config])"><a class="header-link" href="#p.shaper([config])"></a>P.Shaper([config])</h3>
<p>TODO.</p>
<h3 id="p.synth(voice)"><a class="header-link" href="#p.synth(voice)"></a>P.Synth(Voice)</h3>
<p>TODO.</p>
<h2 id="cookbook"><a class="header-link" href="#cookbook"></a>Cookbook</h2>
<p>The philosophy of Partch is to give you a small number of fundamental building blocks while making it as easy as possible to build your own high-level abstractions from those blocks. In that spirit, components such as phasers, chorus effects, analogue-style delays, autopanners and so on are not included. Instead, here are some example patches for you to copy and paste, in the hope that you will modify them to your own taste, creating effects and instruments that are entirely unique to you.</p>
<h3 id="simple-delay"><a class="header-link" href="#simple-delay"></a>Simple delay</h3>
<pre class="hljs"><code>P({
  <span class="hljs-attr">dry</span>: P.Gain(),
  <span class="hljs-attr">wet</span>: P.Gain(<span class="hljs-number">0.5</span>),
  <span class="hljs-attr">delay</span>: P.Delay(<span class="hljs-number">0.5</span>),
  <span class="hljs-attr">feedback</span>: P.Gain(<span class="hljs-number">0.5</span>)
},
  <span class="hljs-string">'in &gt; dry &gt; out'</span>,
  <span class="hljs-string">'in &gt; delay &gt; wet &gt; out'</span>,
  <span class="hljs-string">'delay &gt; feedback &gt; delay'</span>
).test()</code></pre><h3 id="analogue-style-delay"><a class="header-link" href="#analogue-style-delay"></a>Analogue-style delay</h3>
<pre class="hljs"><code>P({
  <span class="hljs-attr">dry</span>: P.Gain(),
  <span class="hljs-attr">wet</span>: P.Gain(<span class="hljs-number">0.5</span>),
  <span class="hljs-attr">delay</span>: P.Delay(<span class="hljs-number">0.5</span>),
  <span class="hljs-attr">feedback</span>: P.Gain(<span class="hljs-number">0.5</span>),
  <span class="hljs-attr">highCut</span>: P.Filter(<span class="hljs-number">5000</span>),
  <span class="hljs-attr">lowCut</span>: P.Filter({ <span class="hljs-attr">type</span>: <span class="hljs-string">'highpass'</span>, <span class="hljs-attr">frequency</span>: <span class="hljs-number">80</span> }),
  <span class="hljs-attr">wow</span>: P.Osc(<span class="hljs-number">0.1</span>),
  <span class="hljs-attr">wowLevel</span>: P.Gain(<span class="hljs-number">0.002</span>),
  <span class="hljs-attr">flutter</span>: P.Osc(<span class="hljs-number">5.3</span>),
  <span class="hljs-attr">flutterLevel</span>: P.Gain(<span class="hljs-number">0.0001</span>)
},
  <span class="hljs-string">'in &gt; dry &gt; out'</span>,
  <span class="hljs-string">'in &gt; highCut &gt; lowCut &gt; delay &gt; wet &gt; out'</span>,
  <span class="hljs-string">'delay &gt; feedback &gt; highCut'</span>,
  <span class="hljs-string">'wow &gt; wowLevel &gt; delay.delayTime'</span>,
  <span class="hljs-string">'flutter &gt; flutterLevel &gt; delay.delayTime'</span>
).test()</code></pre><h3 id="flanger"><a class="header-link" href="#flanger"></a>Flanger</h3>
<pre class="hljs"><code>P({
  <span class="hljs-attr">dry</span>: P.Gain(),
  <span class="hljs-attr">wet</span>: P.Gain(),
  <span class="hljs-attr">dryDelay</span>: P.Delay(<span class="hljs-number">0.02</span>),
  <span class="hljs-attr">wetDelay</span>: P.Delay(<span class="hljs-number">0.02</span>),
  <span class="hljs-attr">depth</span>: P.Gain(<span class="hljs-number">0.02</span>),
  <span class="hljs-attr">feedback</span>: P.Gain(<span class="hljs-number">0.5</span>),
  <span class="hljs-attr">lfo</span>: P.Osc(<span class="hljs-number">0.1</span>)
},
  <span class="hljs-string">'in &gt; dryDelay &gt; dry &gt; out'</span>,
  <span class="hljs-string">'in &gt; wetDelay &gt; wet &gt; out'</span>,
  <span class="hljs-string">'wetDelay &gt; feedback &gt; wetDelay'</span>,
  <span class="hljs-string">'lfo &gt; depth &gt; wetDelay.delayTime'</span>
).test(<span class="hljs-number">5</span>, <span class="hljs-string">'noise'</span>)</code></pre>      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.35.0/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.35.0/mode/javascript/javascript.min.js"></script>
  <script
    src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha256-3edrmyuQ0w65f8gfBsqowzjJe2iM6n0nKciPUp8y+7E="
    crossorigin="anonymous"></script>
  <script type="module">
    import Partch from './index.js'
    let P = Partch()
    let _uniqueId = 0

    document.querySelectorAll('pre code').forEach((codeEl) => {
      // Don't make the setup block interactive!
      if (codeEl.textContent.includes('import')) { return }
      let cm = createCodeMirror(codeEl)
      insertButtonsIntoCodeMirror(cm)
    })

    function createCodeMirror(codeEl) {
      return CodeMirror((cmEl) => {
        codeEl.parentNode.replaceChild(cmEl, codeEl)
      }, {
        value: codeEl.textContent.trim(),
        mode: 'javascript',
        lineNumbers: true,
        viewportMargin: Infinity
      })
    }

    function insertButtonsIntoCodeMirror(cm) {
      let id = `cm-ctrl-${_uniqueId++}`
      $(`<div id="${id}" class="cm-ctrl"><button>▶</button><button>■</button></div>`)
        .insertBefore($(cm.display.wrapper).find('.CodeMirror-scroll'))
      $(`#${id}`).click((e) => {
        if (e.target.textContent === '▶') {
          window.Function('P', `'use strict';${cm.getValue()}`)(P)
        }
        else {
          P.panic()
        }
      })
    }
  </script>
</body>
</html>
